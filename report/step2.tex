\section{Step 2 - Spin verification}
For the second step, we must prove our alley solution is correct with a promela model. We wrote a program in JSPIN for this. To prove correctness, we must show that all cars in the alley at any given time has the same direction.

We rewrote the methods \texttt{enter} and \texttt{leave} from the \texttt{AlleySemaphore} class in our java program into the proctypes \texttt{carUp} and \texttt{carDown}. The point is that instantiations of these procedures represent the car threads in our java program, and mimic their movement by sequentially running the \texttt{enter} and \texttt{leave} methods, encased in an infinite loop. This will actually prove the solution more robust than necessary, since it does not assume how and in what order the cars approach the alley. For example, four cars in the same direction can attempt to enter the alley at the same time in the promela model, but in java program they would queue up behind each other.

The different direction cars are separated in proctypes to reduce the depth and transitions, which was a problem since the amount of states exploded.

We wrote Dijkstra semaphores, equivalent to the ones given in our Java program.

\texttt{init} instantiates the 8 cars and a \texttt{tester} procedure (atomically). The latter contains only assertions for testing purposes. Since JSPIN tests all possible states, it tests the assertions at any point of execution. If no errors are found, the assertions are proven to be invariants of the program, since they are always true.

The result from verifying our program is below:
%TODO: Move this to appendix
\begin{lstlisting}
(Spin Version 6.2.2 -- 6 June 2012)
	+ Partial Order Reduction
Full statespace search for:
	never claim         	- (none specified)
	assertion violations	+
	cycle checks       	- (disabled by -DSAFETY)
	invalid end states	+
State-vector 52 byte, depth reached 20482, ••• errors: 0 •••
   685669 states, stored
  1795395 states, matched
  2481064 transitions (= stored+matched)
        8 atomic steps
hash conflicts:     68035 (resolved)
Stats on memory usage (in Megabytes):
   41.850	equivalent memory usage for states (stored*(State-vector + overhead))
   28.993	actual memory usage for states (compression: 69.28%)
         	state-vector as stored = 32 byte + 12 byte overhead
   64.000	memory used for hash table (-w24)
    6.867	memory used for DFS stack (-m200000)
   99.773	total actual memory usage
unreached in init
	(0 of 11 states)
unreached in proctype tester
	(0 of 4 states)
unreached in proctype carUp
	pan.h:94, state 60, "-end-"
	(1 of 60 states)
unreached in proctype carDown
	pan.h:136, state 60, "-end-"
	(1 of 60 states)
pan: elapsed time 5.71 seconds
pan: rate 120082.14 states/second
\end{lstlisting}

Using our program with eight cars, four in each direction, we proved a few invariants. In \texttt{tester}, we asserted that there was always 4 or fewer cars in the alley at any time, which must be true since max four cars move in the same direction. Both critical regions are respected, such that at most one thread exists in the \texttt{carsRegion} code, and at most two exist beyond the bottom and top semaphores. The former test ensures that only one car has access to the state of the alley at any given point, and the latter ensures that only one car from each direction is requesting access to the alley at any time. Finally, between entering and leaving the alley, each car asserted that it had the same direction as \texttt{alleyDir}. This proves that all cars in the alley must have the same direction at any time.

Since no cars of opposite direction can reside in the alley, no collisions can occur. So we have proven the correctness of our Alley solution.

We did however not prove liveness i.e. that no locks will occur.

The verification used 2481064 transitions with a depth of 20482 with all cars. It complained of two unreached states: the final end state of both car proctypes, which obviously are unreachable since neither ever leave their infinite loops.