\section*{Step 4 - Monitors}
synchronized, notify(), notifyAll().\\
while-wait loop
\subsection{AlleyMonitor}
{\texttt AlleyMonitor} is the subclass of {\texttt Alley} implemented with monitors. The methods {\texttt enter(int no)} and {\texttt leave(no)} are both {\texttt synchronized}, making them mutual exclusive. When a thread calls {\texttt enter} with the first argument being the car number, it enters a while-wait loop until the direction in the alley is not opposite of the cars direction. In this case, the alley is either empty (direction equals zero) or only contains cars going in the same direction, making it safe to enter. The car increments the variable cars, assigns the direction of the alley equal to its own (which only has an effect in case the alley was empty) and terminates the method.\\

The leave method decrements the cars variable, possibly resulting in cars equal to zero. In this case, the thread calls {\tt notifyAll}, waking all the cars in the queue (cars which could not enter yet), and the direction of the alley is set to zero.\\

Writing the monitor version of the alley was straightforward. It did not seem necessary to consider other solutions, since this one is simple and cost effective.

\subsection*{BarrierMonitor}
The {\texttt BarrierMonitor} class, extended from {\texttt Barrier}, is the barrier implemented using monitors. When instantiated, the integers {\texttt cars} and {\texttt threshold} is assigned $0$ and $9$ respectively. A boolean {\texttt on} is set to {\texttt false}, since the barrier is off by default. Two boolean arrays {\texttt waiting} and {\texttt pass}, both of length $9$ (the amount of cars), is initialized with all values {\texttt false}. The monitor contains the three required methods, {\texttt sync(int no)}, {\texttt on()} and {\texttt off()}, overridden from the super class with an additional {\texttt synchronized} keyword to ensure mutual exclusion. The method {\texttt setThreshold(int k)} is also overridden as {\texttt synchronized}.\\

When a thread/car calls the {\texttt sync} method, the argument being equal to the car number, {\texttt cars} is incremented and checked if it is less than or equal to {\texttt threshold}.\\
If it is, the car sets {\texttt waiting[no]} to {\texttt true} and {\texttt pass[no]} to {\texttt false}. The first array keeps track of waiting cars and the second signals when they can leave. The thread then enters a while-wait loop, only exiting it if/when the barrier is turned off or if {\texttt pass[no]} is {\texttt true}.\\
In case {\texttt cars} is less than or equal to {\texttt threshold}, the thread calls {\texttt notifyAll}, waking all waiting cars, and then for all $i=0..9$ assigns {\texttt pass[i]} to {\texttt true} if {\texttt waiting[i]} is {\texttt true}.\\
After either of these cases, the method terminates, and the thread can continue execution of {\texttt run}, allowing the car to move through the barrier.\\

Turning the barrier on or off through {\texttt on} and {\texttt off} flips the value of {\texttt on} respectively. In addition, {\texttt on} will set all values of {\texttt waiting} to {\texttt false} and all of {\texttt pass} to {\texttt true}, wiping the memory of the barrier. {\texttt off} calls {\texttt notifyAll}, allowing all waiting cars to leave. Since {\texttt on} wipes the memory of the barrier, all cars are able to leave even if the barrier is flipped from {\texttt on} and {\texttt off} quickly.\\

The biggest hurdle was somehow signaling cars to know if they could leave, no matter how slow any car might be. The goal was to allow a car to leave when the threshold had been met, even if other cars had already queued up again. With a variable threshold, this meant other cars could pass a lot of times before some slow car would leave the barrier. An early solution was an integer {\texttt turn} which would increment every time the threshold was exceeded. Every car in the queue would save the value of {\texttt turn} when they entered the queue, and could tell if the barrier had been opened since they entered the queue. The problem, though improbable, was that {\texttt turn} might be incremented through all integers until it hit the exact same value before a car woke up.\\

The final solution is always safe, albeit uses a bit more memory (negligible with only $9$ cars). {\texttt pass[i]} would only become {\texttt false} when car $i$ entered the queue. Therefore the car can wait an arbitrary amount of time, and still pass the barrier. Both of the solutions tackled spurious wakeup by saving the state of the barrier, and comparing when the thread wakes up.\\

Compared to the semaphore solution, the monitor solutions for both barrier and alley are much shorter, simpler and elegant. They are much preferred to their semaphore counterparts.

\subsection*{Step 4 - E}

Implemented thresholds - barrier still can't stop ur mom owned dayum xxoxoxo

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:
